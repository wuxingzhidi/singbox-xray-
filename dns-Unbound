#!/bin/bash

# 检查 root 权限
if [ "$(id -u)" != "0" ]; then
   echo "错误：此脚本需要以 root 权限运行" 
   exit 1
fi

# 检测系统类型
if [ -f /etc/os-release ]; then
    . /etc/os-release
    OS=$ID
    OS_LIKE=$ID_LIKE
else
    echo "错误：无法检测操作系统"
    exit 1
fi

# 检测 IPv4/IPv6 支持
detect_ip_support() {
    IPV4_AVAILABLE=0
    IPV6_AVAILABLE=0
    
    # 检测 IPv4 支持
    if ip -4 addr show | grep -q "inet"; then
        IPV4_AVAILABLE=1
    fi
    
    # 检测 IPv6 支持
    if [ -f /proc/sys/net/ipv6/conf/all/disable_ipv6 ]; then
        if [ $(cat /proc/sys/net/ipv6/conf/all/disable_ipv6) -eq 0 ]; then
            IPV6_AVAILABLE=1
        fi
    elif ip -6 addr show | grep -q "inet6"; then
        IPV6_AVAILABLE=1
    fi
    
    echo -e "\n\033[34m检测到网络支持:\033[0m"
    [ $IPV4_AVAILABLE -eq 1 ] && echo "  IPv4 支持: 是"
    [ $IPV6_AVAILABLE -eq 1 ] && echo "  IPv6 支持: 是"
    
    if [ $IPV4_AVAILABLE -eq 0 ] && [ $IPV6_AVAILABLE -eq 0 ]; then
        echo -e "\033[31m错误：未检测到 IPv4 或 IPv6 网络支持\033[0m"
        exit 1
    fi
}

# 设置临时 DNS
setup_temp_dns() {
    echo -e "\n\033[34m设置临时 DNS 解析器...\033[0m"
    
    # 备份当前 DNS 配置
    cp /etc/resolv.conf /etc/resolv.conf.bak.tmp 2>/dev/null
    
    # 使用公共 DNS 作为临时解析
    echo "nameserver 1.1.1.1" > /etc/resolv.conf
    echo "nameserver 8.8.8.8" >> /etc/resolv.conf
    echo "options rotate" >> /etc/resolv.conf
    
    # 解除可能的文件锁定
    chattr -i /etc/resolv.conf 2>/dev/null
    
    echo "临时 DNS 已设置为 Cloudflare 和 Google DNS"
}

# 改进的端口占用检查
check_port_usage() {
    local port=$1
    local protocol=${2:-}
    
    echo -e "\n\033[34m检查端口 $port 占用情况...\033[0m"
    
    # 检测占用端口的服务
    if ss -tuln | grep -q ":$port "; then
        echo -e "\033[31m端口 $port 被以下进程占用:\033[0m"
        ss -tuln | grep ":$port "
        
        # 获取占用进程的详细信息
        local pid_info=$(ss -tulnp | grep ":$port " | head -1 | awk '{print $7}')
        local pid=$(echo "$pid_info" | grep -oP 'pid=\K\d+')
        
        if [ -n "$pid" ]; then
            local process_name=$(ps -p $pid -o comm= 2>/dev/null)
            local service_name=""
            
            # 尝试获取服务名
            if [ -n "$process_name" ]; then
                service_name=$(systemctl status $pid 2>/dev/null | grep -oP "Loaded: loaded \K\/.*" | xargs basename 2>/dev/null)
            fi
            
            echo -e "\n占用进程详情:"
            [ -n "$pid" ] && echo "PID: $pid"
            [ -n "$process_name" ] && echo "进程名: $process_name"
            [ -n "$service_name" ] && echo "服务名: $service_name"
        else
            echo "无法获取占用进程的详细信息"
        fi
        
        return 1
    fi
    
    echo -e "\033[32m端口 $port 可用\033[0m"
    return 0
}

# 改进的释放端口函数
free_port() {
    local port=$1
    
    echo -e "\n\033[34m尝试释放端口 $port...\033[0m"
    
    # 获取占用端口的服务
    local pid_info=$(ss -tulnp | grep ":$port " | head -1 | awk '{print $7}')
    local pid=$(echo "$pid_info" | grep -oP 'pid=\K\d+')
    local process_name=""
    local service_name=""
    
    if [ -n "$pid" ]; then
        process_name=$(ps -p $pid -o comm= 2>/dev/null)
        service_name=$(systemctl status $pid 2>/dev/null | grep -oP "Loaded: loaded \K\/.*" | xargs basename 2>/dev/null)
    fi
    
    # 优先处理已知服务
    if [ -n "$service_name" ]; then
        echo "检测到服务占用: $service_name (PID: $pid)"
        
        read -p "是否停止并禁用此服务? [Y/n]: " stop_service
        if [[ "$stop_service" =~ ^[Nn]$ ]]; then
            echo "跳过服务停止"
            return 1
        fi
        
        systemctl stop $service_name
        systemctl disable $service_name
        echo "已停止并禁用 $service_name"
    elif [ -n "$process_name" ]; then
        echo "检测到进程占用: $process_name (PID: $pid)"
        
        read -p "是否停止此进程? [Y/n]: " stop_process
        if [[ "$stop_process" =~ ^[Nn]$ ]]; then
            echo "跳过进程停止"
            return 1
        fi
        
        kill -9 $pid
        echo "已停止进程 $process_name (PID: $pid)"
    else
        echo "无法识别占用端口的服务"
        return 1
    fi
    
    # 再次检查端口是否释放
    sleep 2
    if ss -tuln | grep -q ":$port "; then
        echo -e "\033[31m警告: 端口 $port 仍被占用!\033[0m"
        return 1
    fi
    
    echo -e "\033[32m端口 $port 已成功释放\033[0m"
    return 0
}

# 强制释放53端口
force_free_port_53() {
    echo -e "\n\033[34m强制释放53端口...\033[0m"
    
    # 停止已知服务
    local services=("systemd-resolved" "dnsmasq" "named")
    for service in "${services[@]}"; do
        if systemctl is-active --quiet "$service" 2>/dev/null; then
            echo "停止服务: $service"
            systemctl stop "$service"
            systemctl disable "$service"
        fi
    done
    
    # 杀死占用进程
    pids=$(lsof -t -i :53 2>/dev/null || ss -tulnp | grep ':53 ' | grep -oP 'pid=\K\d+')
    for pid in $pids; do
        if ps -p $pid > /dev/null; then
            echo "停止进程 (PID: $pid)"
            kill -9 $pid
        fi
    done
    
    # 确保resolv.conf可写
    chattr -i /etc/resolv.conf 2>/dev/null
    
    # 重置resolv.conf
    if [ -L "/etc/resolv.conf" ]; then
        rm -f /etc/resolv.conf
        echo "nameserver 1.1.1.1" > /etc/resolv.conf
        echo "nameserver 8.8.8.8" >> /etc/resolv.conf
        echo "已重置 /etc/resolv.conf"
    fi
    
    echo "等待2秒..."
    sleep 2
    
    # 检查是否成功
    if ss -tuln | grep -q ":53 "; then
        echo -e "\033[31m错误: 无法完全释放53端口\033[0m"
        return 1
    fi
    
    echo -e "\033[32m53端口已成功释放\033[0m"
    return 0
}

# 安装 Unbound
install_unbound() {
    echo -e "\n\033[34m安装 Unbound DNS 服务器...\033[0m"
    
    case $OS in
        ubuntu|debian)
            apt update
            DEBIAN_FRONTEND=noninteractive apt install -y unbound nginx certbot python3-certbot-nginx
            ;;
        centos|rhel|fedora|rocky)
            yum install -y epel-release
            yum install -y unbound nginx certbot python3-certbot-nginx
            ;;
        *)
            echo "不支持的发行版：$OS"
            exit 1
            ;;
    esac
}

# 配置 Unbound
configure_unbound() {
    echo -e "\n\033[34m配置 Unbound...\033[0m"
    
    # 备份原始配置
    [ -f /etc/unbound/unbound.conf ] && cp /etc/unbound/unbound.conf /etc/unbound/unbound.conf.bak

    # 基本安全配置
    cat > /etc/unbound/unbound.conf <<- 'EOL'
server:
  # 接口配置将由脚本自动设置
  do-ip4: yes
  do-ip6: no
  do-udp: yes
  do-tcp: yes
  verbosity: 1
  hide-identity: yes
  hide-version: yes
  aggressive-nsec: yes
  prefetch: yes
  qname-minimisation: yes
  use-caps-for-id: yes
  cache-min-ttl: 3600
  cache-max-ttl: 86400
  num-threads: 2
  msg-cache-size: 64m
  rrset-cache-size: 128m
  so-reuseport: yes
EOL

    # 根据检测结果设置 IPv6 支持
    if [ $IPV6_AVAILABLE -eq 1 ]; then
        sed -i 's/do-ip6: no/do-ip6: yes/' /etc/unbound/unbound.conf
        echo -e "\033[32m已启用 IPv6 支持\033[0m"
    else
        echo -e "\033[33m系统不支持 IPv6，已禁用 IPv6 功能\033[0m"
    fi

    # 添加根服务器
    curl -o /var/lib/unbound/root.hints https://www.internic.net/domain/named.cache
    echo '  root-hints: "/var/lib/unbound/root.hints"' >> /etc/unbound/unbound.conf

    # 启用 DNSSEC
    unbound-anchor -a /var/lib/unbound/root.key
    echo '  auto-trust-anchor-file: "/var/lib/unbound/root.key"' >> /etc/unbound/unbound.conf
    echo '  val-log-level: 2' >> /etc/unbound/unbound.conf
    
    # 设置监听端口
    if [ $IPV4_AVAILABLE -eq 1 ]; then
        echo "  interface: 0.0.0.0@$UNBOUND_PORT" >> /etc/unbound/unbound.conf
    fi
    
    if [ $IPV6_AVAILABLE -eq 1 ]; then
        echo "  interface: ::@$UNBOUND_PORT" >> /etc/unbound/unbound.conf
    fi
    
    # 允许本地访问
    echo "  access-control: 127.0.0.0/8 allow" >> /etc/unbound/unbound.conf
    if [ $IPV6_AVAILABLE -eq 1 ]; then
        echo "  access-control: ::1 allow" >> /etc/unbound/unbound.conf
    fi
    
    # 允许局域网访问（可选）
    echo '  access-control: 192.168.0.0/16 allow' >> /etc/unbound/unbound.conf
    echo '  access-control: 10.0.0.0/8 allow' >> /etc/unbound/unbound.conf
    echo '  access-control: 172.16.0.0/12 allow' >> /etc/unbound/unbound.conf
    
    chown -R unbound:unbound /var/lib/unbound
    echo "Unbound 已配置为监听端口 $UNBOUND_PORT"
}

# 配置 DoT (DNS over TLS)
setup_dot() {
    echo -e "\n\033[34m配置 DNS over TLS (DoT)...\033[0m"
    
    # 添加 DoT 配置
    cat >> /etc/unbound/unbound.conf <<- EOL
  interface: 0.0.0.0@853
  tls-service-key: "/etc/letsencrypt/live/$DOMAIN/privkey.pem"
  tls-service-pem: "/etc/letsencrypt/live/$DOMAIN/fullchain.pem"
  tls-port: 853
  access-control: 0.0.0.0/0 allow
EOL

    if [ $IPV6_AVAILABLE -eq 1 ]; then
        echo "  interface: ::@853" >> /etc/unbound/unbound.conf
        echo "  access-control: ::/0 allow" >> /etc/unbound/unbound.conf
    fi

    # 防火墙开放 853 端口
    if command -v ufw &> /dev/null; then
        ufw allow 853/tcp
    elif command -v firewall-cmd &> /dev/null; then
        firewall-cmd --add-port=853/tcp --permanent
        firewall-cmd --reload
    fi
    
    echo "DoT 已启用: 使用端口 853 (tcp://$DOMAIN:853)"
}

# 配置 DoH (DNS over HTTPS)
setup_doh() {
    echo -e "\n\033[34m配置 DNS over HTTPS (DoH)...\033[0m"
    
    # 创建 Nginx DoH 配置
    cat > /etc/nginx/conf.d/doh.conf <<- EOL
server {
    listen 443 ssl http2;
    $([ $IPV6_AVAILABLE -eq 1 ] && echo "listen [::]:443 ssl http2;")
    server_name $DOMAIN;

    ssl_certificate /etc/letsencrypt/live/$DOMAIN/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/$DOMAIN/privkey.pem;
    
    # TLS 优化配置
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';
    ssl_prefer_server_ciphers on;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 1d;
    ssl_ecdh_curve secp384r1;
    
    # 安全头部
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload";
    add_header X-Content-Type-Options nosniff;
    add_header X-Frame-Options DENY;
    add_header X-XSS-Protection "1; mode=block";
    
    location /dns-query {
        proxy_pass       http://127.0.0.1:${UNBOUND_PORT}/dns-query;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        
        # 保持长连接
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        
        # 客户端超时设置
        proxy_read_timeout 30s;
        proxy_send_timeout 30s;
        
        # 缓冲区设置
        proxy_buffering off;
    }
    
    # 阻止其他路径访问
    location / {
        return 404 'Not Found';
    }
    
    # 访问日志（可选）
    access_log /var/log/nginx/doh-access.log;
    error_log /var/log/nginx/doh-error.log;
}
EOL

    # 测试并重载 Nginx
    nginx -t && systemctl reload nginx
    
    # 防火墙开放 443 端口
    if command -v ufw &> /dev/null; then
        ufw allow 443/tcp
    elif command -v firewall-cmd &> /dev/null; then
        firewall-cmd --add-service=https --permanent
        firewall-cmd --reload
    fi
    
    echo "DoH 已启用: 使用 URL https://$DOMAIN/dns-query"
}

# 申请 SSL 证书
get_ssl_certificate() {
    echo -e "\n\033[34m正在申请 Let's Encrypt SSL 证书...\033[0m"
    
    # 临时使用公共 DNS 进行证书申请
    setup_temp_dns
    
    # 申请证书
    if certbot certonly --nginx --agree-tos --non-interactive \
        -d "$DOMAIN" -m "$EMAIL" --keep-until-expiring; then
        echo -e "\033[32m证书申请成功!\033[0m"
    else
        echo -e "\033[31m证书申请失败!\033[0m"
        echo "请检查:"
        echo "1. 域名是否解析到本机IP"
        echo "2. 防火墙是否开放80/443端口"
        echo "3. 尝试手动申请: certbot certonly --nginx -d $DOMAIN"
        return 1
    fi
    
    # 设置自动续期
    (crontab -l 2>/dev/null; echo "0 3 * * * /usr/bin/certbot renew --quiet && systemctl reload nginx") | crontab -
    
    # 恢复临时 DNS
    [ -f /etc/resolv.conf.bak.tmp ] && mv /etc/resolv.conf.bak.tmp /etc/resolv.conf
}

# 启动服务
start_service() {
    systemctl enable unbound
    systemctl restart unbound
    
    if [ "$ENABLE_DOH" = "y" ]; then
        systemctl enable nginx
        systemctl restart nginx
    fi
}

# 防火墙配置
configure_firewall() {
    echo -e "\n\033[34m配置防火墙...\033[0m"
    
    local unbound_port=${UNBOUND_PORT}
    
    if command -v ufw &> /dev/null; then
        ufw allow ${unbound_port}/tcp
        ufw allow ${unbound_port}/udp
        [ "$ENABLE_DOT" = "y" ] && ufw allow 853/tcp
        [ "$ENABLE_DOH" = "y" ] && ufw allow 443/tcp
        ufw reload
    elif command -v firewall-cmd &> /dev/null; then
        firewall-cmd --add-port=${unbound_port}/tcp --permanent
        firewall-cmd --add-port=${unbound_port}/udp --permanent
        [ "$ENABLE_DOT" = "y" ] && firewall-cmd --add-port=853/tcp --permanent
        [ "$ENABLE_DOH" = "y" ] && firewall-cmd --add-service=https --permanent
        firewall-cmd --reload
    else
        echo "未检测到防火墙，请手动开放端口: $unbound_port (TCP/UDP)"
        [ "$ENABLE_DOT" = "y" ] && echo "853 (TCP)"
        [ "$ENABLE_DOH" = "y" ] && echo "443 (TCP)"
    fi
}

# 设置系统 DNS
configure_system_dns() {
    echo -e "\n\033[34m配置系统使用本地 DNS 解析器...\033[0m"
    
    # 备份当前配置
    cp /etc/resolv.conf /etc/resolv.conf.bak
    
    # 创建新的 resolv.conf
    cat > /etc/resolv.conf <<- EOL
# Generated by Unbound Installer
nameserver 127.0.0.1
$([ $IPV6_AVAILABLE -eq 1 ] && echo "nameserver ::1")
options edns0 trust-ad
EOL
    
    # 防止网络管理器覆盖
    if [ -f /etc/NetworkManager/NetworkManager.conf ]; then
        if ! grep -q "dns=none" /etc/NetworkManager/NetworkManager.conf; then
            sed -i '/^\[main\]$/a dns=none' /etc/NetworkManager/NetworkManager.conf
            systemctl restart NetworkManager
        fi
    fi
    
    # 锁定文件防止修改 (Ubuntu/Debian)
    if [ "$OS" = "ubuntu" ] || [ "$OS" = "debian" ]; then
        chattr +i /etc/resolv.conf 2>/dev/null
    fi
    
    echo "系统 DNS 已设置为 127.0.0.1 (端口 $UNBOUND_PORT)"
    [ $IPV6_AVAILABLE -eq 1 ] && echo "同时配置了 IPv6 DNS (::1)"
}

# 验证安装
verify_installation() {
    sleep 3
    echo -e "\n\033[33m=== 测试标准 DNS ===\033[0m"
    if dig @127.0.0.1 -p $UNBOUND_PORT google.com | grep -q "status: NOERROR"; then
        echo -e "\033[32mIPv4 DNS 解析成功！\033[0m"
    else
        echo -e "\033[31m错误：IPv4 DNS 解析失败\033[0m"
        echo "请检查日志: journalctl -u unbound -n 50 --no-pager"
    fi
    
    if [ $IPV6_AVAILABLE -eq 1 ]; then
        echo -e "\n\033[33m=== 测试 IPv6 DNS ===\033[0m"
        if dig @::1 -p $UNBOUND_PORT google.com | grep -q "status: NOERROR"; then
            echo -e "\033[32mIPv6 DNS 解析成功！\033[0m"
        else
            echo -e "\033[31m错误：IPv6 DNS 解析失败\033[0m"
            echo "请检查日志: journalctl -u unbound -n 50 --no-pager"
        fi
    fi
    
    if [ "$ENABLE_DOT" = "y" ]; then
        echo -e "\n\033[33m=== 测试 DoT (DNS over TLS) ===\033[0m"
        if command -v kdig &>/dev/null; then
            if kdig @$DOMAIN +tls-ca +tls-host=$DOMAIN google.com | grep -q "status: NOERROR"; then
                echo -e "\033[32mDoT 解析成功！\033[0m"
            else
                echo -e "\033[31m错误：DoT 解析失败\033[0m"
            fi
        else
            echo "安装 kdig 以测试 DoT:"
            echo "Ubuntu/Debian: apt install knot-dnsutils"
            echo "CentOS/RHEL: yum install knot-utils"
        fi
    fi
    
    if [ "$ENABLE_DOH" = "y" ]; then
        echo -e "\n\033[33m=== 测试 DoH (DNS over HTTPS) ===\033[0m"
        if curl -s -k -H 'accept: application/dns-json' "https://$DOMAIN/dns-query?name=google.com&type=A" | grep -q "Status"; then
            echo -e "\033[32mDoH 解析成功！\033[0m"
        else
            echo -e "\033[31m错误：DoH 解析失败\033[0m"
            echo "尝试手动测试: curl -v -k 'https://$DOMAIN/dns-query?name=google.com&type=A'"
        fi
    fi
    
    echo -e "\n\033[33m=== 测试系统 DNS 配置 ===\033[0m"
    if ping -c 2 google.com &> /dev/null; then
        echo -e "\033[32m系统 IPv4 DNS 解析正常！\033[0m"
    else
        echo -e "\033[31m错误：系统 IPv4 DNS 解析失败\033[0m"
        echo "检查当前DNS设置: cat /etc/resolv.conf"
    fi
    
    if [ $IPV6_AVAILABLE -eq 1 ]; then
        if ping6 -c 2 google.com &> /dev/null; then
            echo -e "\033[32m系统 IPv6 DNS 解析正常！\033[0m"
        else
            echo -e "\033[31m错误：系统 IPv6 DNS 解析失败\033[0m"
            echo "检查当前DNS设置: cat /etc/resolv.conf"
        fi
    fi
}

# 显示配置摘要
show_summary() {
    echo -e "\n\033[44m=== Unbound 安装完成 ===\033[0m"
    echo -e "\033[32m系统DNS:\033[0m 127.0.0.1:$UNBOUND_PORT (IPv4)"
    [ $IPV6_AVAILABLE -eq 1 ] && echo -e "          ::1:$UNBOUND_PORT (IPv6)"
    
    if [ "$ENABLE_DOT" = "y" ]; then
        echo -e "\033[32mDoT (DNS over TLS):\033[0m tcp://$DOMAIN:853"
    fi
    
    if [ "$ENABLE_DOH" = "y" ]; then
        echo -e "\033[32mDoH (DNS over HTTPS):\033[0m https://$DOMAIN/dns-query"
    fi
    
    echo -e "\n\033[33m测试命令:\033[0m"
    echo "IPv4 DNS: dig @127.0.0.1 -p $UNBOUND_PORT google.com"
    [ $IPV6_AVAILABLE -eq 1 ] && echo "IPv6 DNS: dig @::1 -p $UNBOUND_PORT google.com"
    [ "$ENABLE_DOT" = "y" ] && echo "DoT测试: kdig @$DOMAIN +tls-ca +tls-host=$DOMAIN google.com"
    [ "$ENABLE_DOH" = "y" ] && echo "DoH测试: curl -s 'https://$DOMAIN/dns-query?name=google.com&type=A'"
    
    echo -e "\n\033[33m管理命令:\033[0m"
    echo "重启Unbound: systemctl restart unbound"
    echo "查看日志: journalctl -u unbound -f"
    echo "刷新缓存: unbound-control reload"
    
    if [ "$ENABLE_DOT" = "y" ] || [ "$ENABLE_DOH" = "y" ]; then
        echo -e "\n\033[33m证书信息:\033[0m"
        echo "路径: /etc/letsencrypt/live/$DOMAIN/"
        echo "续期: certbot renew"
    fi
    
    echo -e "\n\033[33m配置文件:\033[0m"
    echo "Unbound: /etc/unbound/unbound.conf"
    [ "$ENABLE_DOH" = "y" ] && echo "Nginx: /etc/nginx/conf.d/doh.conf"
    
    echo -e "\n\033[33m恢复原配置:\033[0m"
    echo "恢复DNS: chattr -i /etc/resolv.conf; mv /etc/resolv.conf.bak /etc/resolv.conf"
    echo "恢复服务: systemctl enable systemd-resolved; systemctl start systemd-resolved"
}

# 主安装流程
main() {
    # 检测网络支持
    detect_ip_support
    
    # 设置临时 DNS 确保脚本正常运行
    setup_temp_dns
    
    echo -e "\n\033[36m===== Unbound DNS 服务器安装向导 =====\033[0m"
    
    # 询问端口配置
    while true; do
        read -p "您想使用哪个端口运行 DNS 服务? (默认: 53) : " UNBOUND_PORT
        UNBOUND_PORT=${UNBOUND_PORT:-53}
        
        # 验证端口输入
        if [[ $UNBOUND_PORT =~ ^[0-9]+$ ]] && [ $UNBOUND_PORT -ge 1 ] && [ $UNBOUND_PORT -le 65535 ]; then
            break
        else
            echo -e "\033[31m错误: 端口必须是1-65535之间的数字\033[0m"
        fi
    done
    
    # 检查端口占用情况
    check_port_usage $UNBOUND_PORT
    port_used=$?
    
    # 如果端口被占用且用户选择53端口
    if [ $port_used -ne 0 ] && [ $UNBOUND_PORT -eq 53 ]; then
        echo -e "\n\033[33m端口53被占用，但您选择使用此端口\033[0m"
        read -p "是否强制释放53端口? [Y/n]: " force_release
        
        if [[ ! "$force_release" =~ ^[Nn]$ ]]; then
            if force_free_port_53; then
                echo -e "\033[32m53端口已成功释放，将继续使用此端口\033[0m"
            else
                echo -e "\033[31m无法释放53端口，安装将退出\033[0m"
                exit 1
            fi
        else
            echo "安装将使用53端口，但可能启动失败"
        fi
    elif [ $port_used -ne 0 ]; then
        # 非53端口被占用
        echo -e "\n\033[33m端口 $UNBOUND_PORT 被占用\033[0m"
        read -p "是否尝试释放此端口? [Y/n]: " free_port_choice
        
        if [[ ! "$free_port_choice" =~ ^[Nn]$ ]]; then
            free_port $UNBOUND_PORT || {
                read -p "无法释放端口 $UNBOUND_PORT，请选择其他端口: " new_port
                UNBOUND_PORT=${new_port:-5353}
                echo "将使用端口: $UNBOUND_PORT"
            }
        else
            read -p "请选择其他端口: " new_port
            UNBOUND_PORT=${new_port:-5353}
            echo "将使用端口: $UNBOUND_PORT"
        fi
    fi
    
    echo -e "\n\033[32mUnbound 将使用端口: $UNBOUND_PORT\033[0m"
    
    # 询问协议选项
    read -p "是否启用 DoT (DNS over TLS)? [y/N]: " ENABLE_DOT
    read -p "是否启用 DoH (DNS over HTTPS)? [y/N]: " ENABLE_DOH
    
    # 如果需要证书
    if [ "$ENABLE_DOT" = "y" ] || [ "$ENABLE_DOH" = "y" ]; then
        while true; do
            read -p "请输入用于申请证书的域名: " DOMAIN
            if [ -n "$DOMAIN" ]; then
                break
            else
                echo -e "\033[31m错误：必须提供域名\033[0m"
            fi
        done
        
        while true; do
            read -p "请输入管理员邮箱: " EMAIL
            if [[ "$EMAIL" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
                break
            else
                echo -e "\033[31m错误：邮箱格式不正确\033[0m"
            fi
        done
    fi

    # 安装必要软件
    install_unbound
    
    # 配置 Unbound
    configure_unbound
    
    # 配置协议
    if [ "$ENABLE_DOT" = "y" ] || [ "$ENABLE_DOH" = "y" ]; then
        get_ssl_certificate
        [ "$ENABLE_DOT" = "y" ] && setup_dot
        [ "$ENABLE_DOH" = "y" ] && setup_doh
    fi

    configure_firewall
    start_service
    
    # 配置系统使用本地 DNS
    configure_system_dns
    
    verify_installation
    show_summary
}

main
